diff --git a/src/lib/persistence.ts b/src/lib/persistence.ts
index 0dc43f3..5b0903c 100644
--- a/src/lib/persistence.ts
+++ b/src/lib/persistence.ts
@@ -2,8 +2,9 @@
  * StateManager - Disk persistence for brain state
  */
 
-import { readFile, writeFile, mkdir, rename, unlink } from "fs/promises"
-import { existsSync, openSync, closeSync } from "fs"
+import { readFile, writeFile, mkdir, rename, unlink, open, readdir, stat } from "fs/promises"
+import type { FileHandle } from "fs/promises"
+import { existsSync } from "fs"
 import { dirname, join } from "path"
 import type { BrainState } from "../schemas/brain-state.js"
 import type { HiveMindConfig } from "../schemas/config.js"
@@ -18,12 +19,11 @@ function isNodeError(err: unknown): err is NodeJS.ErrnoException {
 
 /** Clean up old backup files, keeping only the last 3 versions */
 async function cleanupOldBackups(brainPath: string): Promise<void> {
-  const fs = await import("fs/promises")
   const dir = dirname(brainPath)
   const backupPattern = /brain\.json\.bak\.\d{4}-\d{2}-\d{2}T\d{2}-\d{2}-\d{2}/
   
   try {
-    const files = await fs.readdir(dir)
+    const files = await readdir(dir)
     const backupFiles = files
       .filter(file => backupPattern.test(file))
       .map(file => ({
@@ -37,7 +37,7 @@ async function cleanupOldBackups(brainPath: string): Promise<void> {
     const oldBackups = backupFiles.slice(3)
     for (const backup of oldBackups) {
       try {
-        await fs.unlink(backup.path)
+        await unlink(backup.path)
       } catch (err: unknown) {
         // Ignore errors when deleting old backups
       }
@@ -59,7 +59,7 @@ function getTimestampFromBackupName(filename: string): number {
 // File lock mechanism using exclusive file handles
 class FileLock {
   private lockPath: string
-  private fd: number | null = null
+  private handle: FileHandle | null = null
 
   constructor(lockPath: string) {
     this.lockPath = lockPath
@@ -74,17 +74,16 @@ class FileLock {
     while (Date.now() < timeout) {
       try {
         // Try to acquire exclusive lock
-        this.fd = openSync(this.lockPath, "wx")
+        this.handle = await open(this.lockPath, "wx")
         return // Lock acquired
       } catch (err: unknown) {
         if (isNodeError(err) && err.code === "EEXIST") {
           // Lock file exists, check if it's stale (older than 5 seconds)
-          const fs = await import("fs/promises")
           try {
-            const stat = await fs.stat(this.lockPath)
-            if (Date.now() - stat.mtime.getTime() > 5000) {
+            const s = await stat(this.lockPath)
+            if (Date.now() - s.mtime.getTime() > 5000) {
               // Stale lock, remove it
-              await fs.unlink(this.lockPath)
+              await unlink(this.lockPath)
               continue // Retry acquisition
             }
           } catch (statErr: unknown) {
@@ -104,10 +103,10 @@ class FileLock {
   }
 
   async release(): Promise<void> {
-    if (this.fd !== null) {
+    if (this.handle !== null) {
       try {
-        closeSync(this.fd)
-        this.fd = null
+        await this.handle.close()
+        this.handle = null
         await unlink(this.lockPath).catch(() => {
           // Ignore errors when removing lock file
         })
@@ -359,4 +358,4 @@ export async function saveConfig(
     }
     throw new Error(`Failed to save config: ${error}`)
   }
-}
\ No newline at end of file
+}

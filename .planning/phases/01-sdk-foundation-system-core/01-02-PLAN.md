---
phase: 01-sdk-foundation-system-core
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - src/hooks/event-handler.ts
  - src/index.ts
  - src/hooks/index.ts
  - package.json
  - scripts/check-sdk-boundary.sh
  - tests/sdk-foundation.test.ts
autonomous: true

must_haves:
  truths:
    - "Event hook receives and logs session.created, session.idle, session.compacted, file.edited, session.diff events"
    - "src/lib/ has zero @opencode-ai imports verified by automated lint rule"
    - "Plugin functions fully (14 tools, 4 hooks + event) when SDK client is unavailable"
    - "SDK context module correctly stores and retrieves all 4 SDK refs"
    - "withClient gracefully returns fallback when client is null or throws"
  artifacts:
    - path: "src/hooks/event-handler.ts"
      provides: "Event hook dispatching SDK events to governance engine"
      exports: ["createEventHandler"]
    - path: "scripts/check-sdk-boundary.sh"
      provides: "Architecture enforcement script"
      contains: "grep.*@opencode-ai.*src/lib"
    - path: "tests/sdk-foundation.test.ts"
      provides: "Comprehensive tests for SDK foundation"
      min_lines: 100
  key_links:
    - from: "src/index.ts"
      to: "src/hooks/event-handler.ts"
      via: "event hook in Hooks return object"
      pattern: "event:.*createEventHandler"
    - from: "src/hooks/event-handler.ts"
      to: "src/hooks/sdk-context.ts"
      via: "imports getClient for logging SDK info"
      pattern: "getClient"
    - from: "package.json"
      to: "scripts/check-sdk-boundary.sh"
      via: "lint:boundary npm script"
      pattern: "lint:boundary"
---

<objective>
Add event-driven governance hook, architecture enforcement, and comprehensive tests.

Purpose: Event hook enables real SDK event-driven governance (replacing turn-counting hacks in Phase 2). Architecture enforcement prevents accidental SDK imports in portable lib. Tests prove the entire SDK foundation works correctly with and without SDK client.

Output: `src/hooks/event-handler.ts` (new), `scripts/check-sdk-boundary.sh` (new), `tests/sdk-foundation.test.ts` (new), updated `src/index.ts`, `src/hooks/index.ts`, `package.json`
</objective>

<execution_context>
@/Users/apple/.config/opencode/get-shit-done/workflows/execute-plan.md
@/Users/apple/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-sdk-foundation-system-core/01-01-SUMMARY.md

@src/index.ts
@src/hooks/sdk-context.ts
@src/hooks/index.ts
@node_modules/@opencode-ai/plugin/dist/index.d.ts
@node_modules/@opencode-ai/sdk/dist/gen/types.gen.d.ts
@tests/integration.test.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Event Handler Hook + Wire into Plugin Entry</name>
  <files>src/hooks/event-handler.ts, src/index.ts, src/hooks/index.ts</files>
  <action>
**Part A — Create `src/hooks/event-handler.ts`:**

Create the event hook that OpenCode calls when SDK events fire. This is a new (5th) hook.

1. Import types from `@opencode-ai/sdk`:
   - `Event` (the union type of all 32+ event types)
   - Specific event types for type narrowing: `EventSessionCreated`, `EventSessionIdle`, `EventSessionCompacted`, `EventFileEdited`, `EventSessionDiff`

2. Import from local modules:
   - `Logger` from `../lib/logging.js`
   - `createStateManager` from `../lib/persistence.js`

3. Create `createEventHandler(log: Logger, directory: string)` factory function that returns the hook:

```typescript
export function createEventHandler(log: Logger, directory: string) {
  const stateManager = createStateManager(directory)

  return async (input: { event: Event }): Promise<void> => {
    try {
      const { event } = input

      switch (event.type) {
        case "session.created":
          await log.info(`[event] session.created: ${event.properties.info.id}`)
          // Phase 2 will wire this to governance bootstrap
          break

        case "session.idle":
          await log.info(`[event] session.idle: ${event.properties.sessionID}`)
          // Phase 2 will wire this to Time-to-Stale check
          // (replacing turn-count approximation with real idle detection)
          break

        case "session.compacted":
          await log.info(`[event] session.compacted: ${event.properties.sessionID}`)
          // Phase 3 will wire this to integrity check
          // (hierarchy, brain state, mems consistency validation)
          break

        case "file.edited":
          await log.debug(`[event] file.edited: ${event.properties.file}`)
          // Phase 2 will wire this to file-aware governance
          // Track which files are being edited for context enrichment
          break

        case "session.diff":
          await log.debug(`[event] session.diff: ${event.properties.sessionID} (${event.properties.diff.length} files)`)
          // Phase 3 will use this for auto-export session diffs
          break

        default:
          // Log unhandled events at debug level for discoverability
          await log.debug(`[event] ${(event as any).type} (unhandled)`)
          break
      }
    } catch (error) {
      // P3: Never break event handling
      await log.error(`Event handler error: ${error}`)
    }
  }
}
```

Key design decisions:
- Factory pattern matches existing hooks (createSessionLifecycleHook, etc.)
- Receives `(log, directory)` — same pattern as createCompactionHook
- Does NOT receive `initConfig` — it will re-read from disk when governance logic is added in Phase 2
- try/catch wrapper (P3 principle — never crash the plugin)
- Each event case has a comment explaining what Phase 2/3 will do with it
- The 5 events match SDK-02 requirement exactly: session.created, session.idle, session.compacted, file.edited, session.diff

**Part B — Update `src/index.ts`:**

1. Add import: `import { createEventHandler } from "./hooks/index.js"` (add to existing destructured import)

2. In the Hooks return object, add the event hook BEFORE the tool section:
   ```typescript
   return {
     /**
      * Hook: Event-driven governance
      * Handles session.created, session.idle, session.compacted, file.edited, session.diff
      */
     event: createEventHandler(log, effectiveDir),

     /**
      * Custom tools for session governance
      */
     tool: {
       // ... existing tools unchanged
     },
     // ... existing hooks unchanged
   }
   ```

3. Update the JSDoc block at the top of the plugin entry to list 5 hooks instead of 4:
   - Change "4 Hooks" → "5 Hooks" in the architecture comment
   - Add "event-driven governance (event)" to the hooks list

**Part C — Update `src/hooks/index.ts`:**

Add to barrel exports:
```typescript
export { createEventHandler } from "./event-handler.js"
```
  </action>
  <verify>
Run `npx tsc --noEmit` — should compile without errors.
Run `npm test` — all existing tests must still pass.
Grep: `grep 'event:' src/index.ts` should show the event hook wiring.
Grep: `grep 'createEventHandler' src/hooks/index.ts` should show the export.
  </verify>
  <done>
`src/hooks/event-handler.ts` exists and handles 5 event types (session.created, session.idle, session.compacted, file.edited, session.diff). Event hook wired into plugin entry in `src/index.ts`. Barrel export updated. All existing tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add Architecture Boundary Enforcement</name>
  <files>scripts/check-sdk-boundary.sh, package.json</files>
  <action>
**Part A — Create `scripts/check-sdk-boundary.sh`:**

Create a shell script that enforces the architecture boundary rule: `src/lib/` MUST NOT import from `@opencode-ai/*`.

```bash
#!/usr/bin/env bash
# Architecture boundary check: src/lib/ must never import @opencode-ai
# This enforces the SDK = materialization layer principle.
# Core concepts in src/lib/ must be platform-portable.

set -euo pipefail

VIOLATIONS=$(grep -rn '@opencode-ai' src/lib/ 2>/dev/null || true)

if [ -n "$VIOLATIONS" ]; then
  echo "❌ Architecture boundary violation: src/lib/ imports @opencode-ai"
  echo ""
  echo "src/lib/ must NEVER import from @opencode-ai/*."
  echo "Only src/hooks/ may touch SDK types."
  echo ""
  echo "Violations found:"
  echo "$VIOLATIONS"
  exit 1
fi

echo "✅ Architecture boundary clean: src/lib/ has zero @opencode-ai imports"
exit 0
```

Mark executable: the plan executor should run `chmod +x scripts/check-sdk-boundary.sh` after creating.

**Part B — Update `package.json`:**

Add new script to the `scripts` section:
```json
"lint:boundary": "bash scripts/check-sdk-boundary.sh"
```

Also update the `test` script to include the boundary check. Change from:
```json
"test": "tsx --test tests/**/*.test.ts"
```
to:
```json
"test": "bash scripts/check-sdk-boundary.sh && tsx --test tests/**/*.test.ts"
```

This ensures the boundary check runs on EVERY `npm test`, catching violations early. The boundary check is fast (single grep) so adds negligible overhead.

**Why a script file instead of inline:** The script provides clear error messages with violation details. An inline `! grep -r '@opencode-ai' src/lib/` would just fail silently.
  </action>
  <verify>
Run `bash scripts/check-sdk-boundary.sh` — should output "✅ Architecture boundary clean" and exit 0.
Run `npm run lint:boundary` — should succeed.
Run `npm test` — should run boundary check THEN tests, all passing.
  </verify>
  <done>
`scripts/check-sdk-boundary.sh` exists and is executable. `npm run lint:boundary` runs the check. `npm test` includes boundary enforcement before test suite. `src/lib/` has zero `@opencode-ai` imports confirmed.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create Comprehensive SDK Foundation Tests</name>
  <files>tests/sdk-foundation.test.ts</files>
  <action>
Create `tests/sdk-foundation.test.ts` — comprehensive tests covering the entire SDK foundation (SDK-01 through SDK-05).

Follow the existing test pattern from `tests/integration.test.ts`: custom assert harness, tmpDir setup/cleanup, direct module imports.

**Test structure (6 test groups, ~40+ assertions):**

**Group 1: SDK Context Module (sdk-context.ts) — ~12 assertions**

```
test: initial state — all getters return null
test: initSdkContext stores refs — all getters return values
test: resetSdkContext clears all refs — all getters return null again
test: isSdkAvailable returns false initially, true after init, false after reset
test: initSdkContext with partial input — client only, others null (graceful)
```

Create mock objects for testing:
```typescript
const mockClient = { session: {}, tui: {}, file: {}, find: {} } as any
const mockShell = (() => {}) as any
const mockServerUrl = new URL("http://localhost:3000")
const mockProject = { id: "test", worktree: "/tmp", time: { created: Date.now() } } as any
```

Import `initSdkContext, getClient, getShell, getServerUrl, getProject, resetSdkContext, isSdkAvailable` from `../src/hooks/sdk-context.js`. Call `resetSdkContext()` in each test setup to prevent cross-test pollution.

**Group 2: withClient Graceful Fallback — ~8 assertions**

```
test: withClient returns undefined when client is null (no init)
test: withClient returns fallback value when client is null
test: withClient calls fn with client when available
test: withClient returns fallback when fn throws
test: withClient returns undefined when fn throws and no fallback given
test: withClient handles async fn correctly
```

Import `withClient` from `../src/hooks/sdk-context.js`.

**Group 3: Plugin Entry Wiring (src/index.ts) — ~5 assertions**

These are static code analysis tests (grep-based), not runtime tests:
```
test: index.ts destructures client from PluginInput
test: index.ts destructures $ (shell) from PluginInput
test: index.ts destructures serverUrl from PluginInput
test: index.ts destructures project from PluginInput
test: index.ts calls initSdkContext
```

Read `src/index.ts` via `fs/promises.readFile` and assert content contains expected patterns. This is a pragmatic approach since the plugin entry requires a running OpenCode server to actually execute.

**Group 4: Event Handler — ~8 assertions**

```
test: createEventHandler returns a function
test: event handler handles session.created without throwing
test: event handler handles session.idle without throwing
test: event handler handles session.compacted without throwing
test: event handler handles file.edited without throwing
test: event handler handles session.diff without throwing
test: event handler handles unknown event type without throwing
test: event handler catches errors (bad event) without throwing
```

Create a mock logger: `{ debug: async () => {}, info: async () => {}, warn: async () => {}, error: async () => {} }`. Use tmpDir from setup. Pass mock events matching the SDK Event type signatures.

**Group 5: Architecture Boundary — ~3 assertions**

```
test: src/lib/ has zero @opencode-ai imports (exec grep)
test: src/hooks/ has @opencode-ai imports (proving the boundary is in the right place)
test: boundary check script exists and is executable
```

Use `child_process.execSync` to run `grep -r '@opencode-ai' src/lib/` and verify it finds nothing. Run `grep -r '@opencode-ai' src/hooks/` and verify it finds something (proving the boundary layer exists).

**Group 6: Backward Compatibility — ~5 assertions**

```
test: all 14 tool creators still export from tools/index.ts
test: all 4 original hook creators still export from hooks/index.ts
test: createEventHandler also exported from hooks/index.ts (5th hook)
test: SDK context functions exported from hooks/index.ts
test: hooks/index.ts exports at least 13 named exports
```

Import from `../src/hooks/index.js` and `../src/tools/index.js`, assert all functions are defined.

**Final reporting:**
Print `sdk-foundation: ${passed} passed, ${failed_} failed out of ${passed + failed_}` and `process.exit(failed_ > 0 ? 1 : 0)`.

**Critical test constraint:** Call `resetSdkContext()` before each SDK context test group to prevent cross-test state pollution. The module singleton pattern means state persists across tests.
  </action>
  <verify>
Run `tsx --test tests/sdk-foundation.test.ts` — all assertions pass.
Run `npm test` — sdk-foundation tests included in full suite, total assertions ≥ 745.
  </verify>
  <done>
`tests/sdk-foundation.test.ts` exists with 40+ assertions covering: SDK context module (init/get/reset/availability), withClient graceful fallback (null client, error handling, async), plugin entry wiring (static analysis), event handler (all 5 event types + error handling), architecture boundary (grep verification), backward compatibility (exports verification). All pass. Total project assertions ≥ 745.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes (type safety for all new files)
2. `npm test` passes with ≥ 745 assertions (705 existing + 40+ new)
3. `bash scripts/check-sdk-boundary.sh` outputs "✅ Architecture boundary clean"
4. `grep -c 'event:' src/index.ts` returns 1 (event hook wired)
5. `tsx --test tests/sdk-foundation.test.ts` passes independently
6. Event handler does not crash on any of the 5 target event types
7. withClient returns fallback when client unavailable (graceful degradation)
</verification>

<success_criteria>
- SDK-01: ✅ (verified in Plan 01, confirmed by static analysis tests here)
- SDK-02: ✅ Event hook handles session.created, session.idle, session.compacted, file.edited, session.diff
- SDK-03: ✅ (verified in Plan 01, confirmed by unit tests here)
- SDK-04: ✅ Architecture boundary enforced by script, wired into npm test
- SDK-05: ✅ withClient() tested with null client, throwing fn, and async scenarios

All 5 Phase 1 requirements have full coverage.
Total test assertions ≥ 745 (never dropped below 700 threshold).
</success_criteria>

<output>
After completion, create `.planning/phases/01-sdk-foundation-system-core/01-02-SUMMARY.md`
</output>

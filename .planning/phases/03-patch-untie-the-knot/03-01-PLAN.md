---
phase: 03-patch-untie-the-knot
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  # Stage 1: Clean house
  - package.json
  - package-lock.json
  - .gitignore
  # Stage 2: Manifest & persistence integrity
  - src/lib/planning-fs.ts
  - src/lib/persistence.ts
  - src/schemas/brain-state.ts
  # Stage 3: First-turn context pull
  - src/hooks/session-lifecycle.ts
  - src/hooks/compaction.ts
  # Stage 4: Delegation protection
  - src/hooks/tool-gate.ts
  - src/hooks/soft-governance.ts
  # Tests
  - tests/planning-fs.test.ts
  - tests/integration.test.ts
autonomous: true

must_haves:
  truths:
    - "First turn ALWAYS pulls brain state + hierarchy + anchors + mems — no path where context is absent"
    - "Manifest deduplication: registerSession never creates duplicate stamp entries"
    - "persistence.ts logs errors instead of silently returning null"
    - "Compaction hook injects purification report AND standard context (both, not either)"
    - "All fixes are transparent to delegation flows — subagent tool calls (export_cycle, task) are not impacted"
    - "Dirty git state cleaned: self-reference removed, noise files gitignored or archived"
  artifacts:
    - path: "src/lib/planning-fs.ts"
      provides: "Manifest deduplication + stamp-uniqueness guard"
      contains: "stamp === existingEntry.stamp"
    - path: "src/lib/persistence.ts"
      provides: "Error logging instead of silent null return"
      contains: "log.error"
    - path: "src/hooks/session-lifecycle.ts"
      provides: "Unconditional first-turn context pull — brain, hierarchy, anchors, mems summary"
      contains: "compileFirstTurnContext"
    - path: "src/hooks/compaction.ts"
      provides: "Verified purification + standard context dual injection"
      contains: "purificationReport"
    - path: "src/hooks/tool-gate.ts"
      provides: "Delegation-safe tool gate — no regression for export_cycle, task, todowrite"
      contains: "export_cycle"
  key_links:
    - from: "src/hooks/session-lifecycle.ts"
      to: "src/lib/persistence.ts"
      via: "stateManager.load() with error propagation instead of silent null"
      pattern: "createStateManager"
    - from: "src/hooks/session-lifecycle.ts"
      to: "src/lib/planning-fs.ts"
      via: "registerSession dedup guard prevents manifest bloat"
      pattern: "registerSession"
    - from: "src/hooks/compaction.ts"
      to: "src/tools/compact-session.ts"
      via: "next_compaction_report written by compact, consumed by compaction hook"
      pattern: "next_compaction_report"
---

<objective>
Untie the knot — fix the foundational bugs that make every session start broken, every
manifest bloated, and every compaction lossy. One consolidated plan, four stages, each
stage's output feeds the next. Every fix is transparent to delegation flows (subagent
tool calls must not regress).

User story: "When I open a new session, the AI already knows everything from last
session — hierarchy, anchors, mems, what I was working on. It never starts blank.
Manifest doesn't grow duplicates. Errors are visible, not silently swallowed.
Subagent delegation keeps working exactly as before."
</objective>

<execution_context>
@/Users/apple/.config/opencode/get-shit-done/workflows/execute-plan.md
@/Users/apple/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/REQUIREMENTS.md
@.planning/codebase/CONCERNS.md
@.planning/codebase/TOOLS_ANALYSIS.md

@src/lib/planning-fs.ts
@src/lib/persistence.ts
@src/schemas/brain-state.ts
@src/hooks/session-lifecycle.ts
@src/hooks/compaction.ts
@src/hooks/tool-gate.ts
@src/hooks/soft-governance.ts
@tests/planning-fs.test.ts
@tests/integration.test.ts
</context>

<tasks>

<!-- ============================================================ -->
<!-- STAGE 1: CLEAN HOUSE                                          -->
<!-- Fix dirty git state so every subsequent commit is clean        -->
<!-- ============================================================ -->

<task type="auto">
  <name>Task 1: Clean dirty git state</name>
  <files>package.json, package-lock.json, .gitignore</files>
  <action>
    1. Remove self-reference `"hivemind-context-governance": "^2.6.0"` from
       package.json dependencies (it's the package itself — circular).
    2. Regenerate package-lock.json (`npm install`).
    3. Add to .gitignore:
       - `this-is-what-fuck-happened.md`
       - `fucking-shallow-output-worse-than-the-GSD-without-this.md`
       - `session-ses_*.md`
       - `docs/image.png` (if it's a temp artifact — confirm first)
    4. Stage and commit: "fix: remove self-reference dep, gitignore session exports"
    5. The `bin/hm-reality-check.sh` stays untracked for now (Stage 5 may adopt it).
  </action>
  <verify>
    `git status` shows clean working tree (no modified, only expected untracked).
    `npm run build` succeeds. `npm run typecheck` succeeds.
  </verify>
  <done>Working tree clean. Self-reference removed. Noise files gitignored.</done>
</task>

<!-- ============================================================ -->
<!-- STAGE 2: MANIFEST & PERSISTENCE INTEGRITY                     -->
<!-- Fix the data layer so everything above can trust it            -->
<!-- ============================================================ -->

<task type="auto">
  <name>Task 2: Fix manifest deduplication in registerSession</name>
  <files>src/lib/planning-fs.ts, tests/planning-fs.test.ts</files>
  <action>
    In `registerSession()` (line ~203), BEFORE pushing a new entry:
    1. Check if an entry with the same `stamp` already exists.
    2. If it does, update the existing entry's status to "active" and update its
       `created` timestamp — do NOT push a duplicate.
    3. If it doesn't, push as before.

    Add a `deduplicateManifest()` helper that can be called on any manifest to
    remove duplicate stamp entries (keeping the newest by `created` timestamp).
    This is the repair function for existing corrupted manifests.

    Write tests:
    - registerSession with duplicate stamp → no duplicate entries
    - deduplicateManifest on manifest with 5 identical stamps → 1 entry remains
    - Normal flow (new stamp) → works as before
  </action>
  <verify>
    `npx tsx --test tests/planning-fs.test.ts` passes with dedup assertions.
    Manually inspect `.hivemind/sessions/manifest.json` after running dedup.
  </verify>
  <done>registerSession is idempotent on stamps. Existing corrupt manifests can be repaired.</done>
</task>

<task type="auto">
  <name>Task 3: Fix silent error swallowing in persistence.ts</name>
  <files>src/lib/persistence.ts</files>
  <action>
    The `load()` function (around line 70-72) catches ALL errors and returns `null`.
    This hides JSON parse errors, permission errors, and disk errors.

    Fix:
    1. Add optional `Logger` parameter to `createStateManager()` factory.
    2. In catch blocks, if logger is available, call `log.error(...)` with the
       actual error message and file path.
    3. For JSON parse errors specifically, log the error AND return null (the caller
       should create fresh state). But log it so the user sees corruption.
    4. For file-not-found (ENOENT), return null silently (this is expected on first run).
    5. For other errors (EPERM, EIO), log AND return null.

    DO NOT change the return type or add throws — callers already handle null.
    The fix is observability, not control flow change.
  </action>
  <verify>
    `npm run typecheck` passes. `npm test` passes (no regression).
    Introduce a corrupt brain.json in a temp dir and verify error is logged.
  </verify>
  <done>persistence.ts logs errors by category. Silent swallowing eliminated for all but ENOENT.</done>
</task>

<!-- ============================================================ -->
<!-- STAGE 3: FIRST-TURN CONTEXT PULL                              -->
<!-- Make session-lifecycle.ts ALWAYS pull full context on turn 0-1 -->
<!-- ============================================================ -->

<task type="auto">
  <name>Task 4: Implement unconditional first-turn context compilation</name>
  <files>src/hooks/session-lifecycle.ts, tests/integration.test.ts</files>
  <action>
    Current problem: First turn shows bootstrap block (teaching what HiveMind is)
    but does NOT pull prior session context — no anchors summary, no mems count,
    no last-session trajectory. The agent starts blind.

    Fix — add `compileFirstTurnContext()` function that:
    1. Loads anchors.json → summarize as key-value pairs (budget: 300 chars)
    2. Loads mems.json → count + last 2 mem summaries (budget: 200 chars)
    3. Reads last compaction report from brain.json.next_compaction_report
       (if present, include cursor path + resume instructions)
    4. Checks for prior session summary in manifest → include trajectory/tactic
       from the most recently archived session (budget: 200 chars)

    Integration:
    - Call `compileFirstTurnContext()` and push result into a new P0.3 priority
      section (between bootstrap P0 and evidence P0.5).
    - This fires on ALL turns where `turn_count <= 2`, regardless of governance mode.
    - Expand first-turn budget from 4000 to 4500 chars to accommodate.

    Conditional refresh (turns > 2):
    - Anchors continue to be shown via existing P4 section.
    - Mems count continues to be shown via compaction hook.
    - No additional injection needed beyond turn 2.

    Write/update tests:
    - Turn 0 with existing anchors → anchors appear in injection
    - Turn 0 with existing mems → mems count appears in injection
    - Turn 0 with prior session in manifest → prior trajectory appears
    - Turn 3+ → first-turn context section absent (budget savings)
  </action>
  <verify>
    `npx tsx --test tests/integration.test.ts` passes with first-turn context assertions.
    `npm run typecheck` passes. Total injection stays under 4500 chars on turn 0.
  </verify>
  <done>Turn 0-1 always includes: anchors summary, mems count, prior session trajectory, resume instructions. Agent never starts blind.</done>
</task>

<task type="auto">
  <name>Task 5: Verify compaction hook dual-injection flow</name>
  <files>src/hooks/compaction.ts, tests/integration.test.ts</files>
  <action>
    Current compaction.ts line 59 says: "Don't return — still add standard context
    too, but purification report comes first." Verify this is actually happening:

    1. Read the flow: if `next_compaction_report` exists, it's pushed to
       `output.context`, then standard context is also pushed. Good.
    2. BUT: after consuming the report, it saves state with `next_compaction_report: null`.
       This means the NEXT turn's session-lifecycle.ts won't see the report either.
       The report is consumed ONCE by the compaction hook, then gone.

    Fix: After compaction hook consumes the report, the first-turn context compiler
    (Task 4) should NOT also try to read `next_compaction_report` — it will be null.
    Instead, the compaction hook's `output.context` injection IS the authoritative
    post-compaction context. Task 4's first-turn pull should check
    `brain.compaction_count > 0 && brain.last_compaction_time` to know this is a
    post-compaction session and skip redundant prior-session lookup.

    Add guard: if `compaction_count > 0` and `turn_count <= 1`, the first-turn
    context compiler defers to the compaction hook's injection (no duplicate).

    Write test:
    - Post-compaction turn 0: compaction hook injects purification report + standard
      context. First-turn context does NOT duplicate the hierarchy/trajectory info.
  </action>
  <verify>
    `npx tsx --test tests/integration.test.ts` with post-compaction scenario passes.
    No duplicate hierarchy/trajectory in combined injection.
  </verify>
  <done>Compaction and first-turn flows are coordinated. No duplicate, no gap.</done>
</task>

<!-- ============================================================ -->
<!-- STAGE 4: DELEGATION PROTECTION                                -->
<!-- Verify subagent flows are not broken by Stages 1-3            -->
<!-- ============================================================ -->

<task type="auto">
  <name>Task 6: Verify delegation flow transparency</name>
  <files>src/hooks/tool-gate.ts, src/hooks/soft-governance.ts, tests/integration.test.ts</files>
  <action>
    Verify that NONE of the changes in Stages 1-3 impact delegation:

    1. tool-gate.ts: Confirm `export_cycle`, `task`, `todowrite`, `todoread` remain
       in the exempt/pass-through list. No new gates added that could block them.
    2. soft-governance.ts: Confirm `task` and `todowrite` are still classified as
       "query" type (not "write") in detection, so they don't trigger write-without-read.
    3. session-lifecycle.ts: Confirm the new `compileFirstTurnContext()` doesn't
       interfere with subagent sessions (subagents have their own sessionID).
    4. Confirm `persistence.ts` logger parameter is optional — subagents that
       create stateManager without logger still work.

    This is a VERIFICATION task, not a coding task. If any regression is found,
    fix it immediately and document what changed.

    Write regression test:
    - Call export_cycle tool → not blocked by tool-gate
    - tool-gate exemption list includes all delegation tools
    - soft-governance classifies task/todowrite as "query"
  </action>
  <verify>
    `npm test` — all 41+ suites pass. `npm run typecheck` passes.
    `npm run lint:boundary` passes (no SDK imports in src/lib/).
  </verify>
  <done>All delegation flows verified transparent. No regression from Stages 1-3.</done>
</task>

<!-- ============================================================ -->
<!-- STAGE 5: ARCHIVE NOISE & MAP USER STORY                       -->
<!-- Clean .hivemind/ state, commit everything, update STATE.md     -->
<!-- ============================================================ -->

<task type="auto">
  <name>Task 7: Clean .hivemind/ manifest and archive noise</name>
  <files>.hivemind/sessions/manifest.json</files>
  <action>
    1. Run `deduplicateManifest()` on the live manifest to fix the 5 duplicate
       `110413022026` entries.
    2. Verify archived sessions in manifest have matching files in sessions/ dir.
       Remove manifest entries for files that don't exist.
    3. Move `10-commandments.md` from `.hivemind/` root to `docs/` — it's a design
       doc, not runtime state.
    4. Verify `.hivemind/brain.json.bak` is not stale (if it matches brain.json,
       it's fine; if it's from a different session, delete it).

    This can be done via a one-time script or manually. The dedup function from
    Task 2 handles the programmatic part.
  </action>
  <verify>
    `.hivemind/sessions/manifest.json` has no duplicate stamps.
    All manifest entries point to existing files.
    `10-commandments.md` is in `docs/`, not `.hivemind/`.
  </verify>
  <done>.hivemind/ is clean. Manifest integrity restored. Docs separated from state.</done>
</task>

<task type="auto">
  <name>Task 8: Update STATE.md and create phase summary</name>
  <files>.planning/STATE.md, .planning/phases/03-patch-untie-the-knot/03-01-SUMMARY.md</files>
  <action>
    1. Update `.planning/STATE.md`:
       - Mark Phase 03 as complete
       - Record what was fixed (manifest dedup, persistence logging, first-turn
         context pull, compaction coordination, delegation verification)
       - Note dirty git state resolved
    2. Create `03-01-SUMMARY.md` following the GSD summary template:
       - What changed (files, line counts)
       - What was verified (test results)
       - What's next (Pillar 1: Packing Automation, Pillar 2: .hivemind/ Reorg,
         Pillar 3: TODO/Task Governance)
    3. Final commit: "feat(phase-03): untie the knot — manifest dedup, first-turn
       context pull, persistence observability"
  </action>
  <verify>
    `npm test` passes. `npm run typecheck` passes. `npm run build` passes.
    `git log --oneline -3` shows clean commit history.
  </verify>
  <done>Phase 03 documented, committed, and ready for next phase.</done>
</task>

</tasks>

<verification>
1. `npm run build` — clean compile, no errors
2. `npm run typecheck` — `tsc --noEmit` passes
3. `npm test` — all suites pass (41+ existing + new)
4. `npm run lint:boundary` — no SDK imports in src/lib/
5. `git status` — clean working tree after final commit
6. Manual: open new OpenCode session with hivemind → first turn shows anchors,
   mems count, prior trajectory (not blank)
7. Manual: call compact_session → next session's first turn shows purification
   report + standard context (not duplicate)
</verification>

<success_criteria>
- First turn is NEVER blank — agent always knows prior context
- Manifest never has duplicate stamp entries (registerSession is idempotent)
- persistence.ts errors are logged, not silently swallowed
- Compaction and first-turn flows don't duplicate context
- All delegation tools (export_cycle, task, todowrite) work exactly as before
- Dirty git state resolved — clean working tree
- .hivemind/ noise archived — manifest integrity restored
</success_criteria>

<output>
After completion, create `.planning/phases/03-patch-untie-the-knot/03-01-SUMMARY.md`
</output>

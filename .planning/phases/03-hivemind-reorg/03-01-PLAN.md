---
phase: 03-hivemind-reorg
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  # New: single source of truth
  - src/lib/paths.ts
  # Migrate resolvers
  - src/lib/planning-fs.ts
  - src/lib/persistence.ts
  - src/lib/hierarchy-tree.ts
  - src/lib/anchors.ts
  - src/lib/mems.ts
  # Migrate scattered hardcoded paths
  - src/index.ts
  - src/hooks/session-lifecycle.ts
  - src/tools/declare-intent.ts
  - src/cli.ts
  - src/cli/init.ts
  # Migration script
  - src/lib/migrate.ts
  # Manifest system
  - src/lib/manifest.ts
  # Tests
  - tests/paths.test.ts
  - tests/migration.test.ts
  - tests/init-planning.test.ts
  - tests/entry-chain.test.ts
  - tests/integration.test.ts
  - tests/hierarchy-tree.test.ts
  - tests/round3-tools.test.ts
  - tests/round4-mems.test.ts
  - tests/ecosystem-check.test.ts
autonomous: false

must_haves:
  truths:
    - "Every .hivemind path in the codebase resolves through src/lib/paths.ts — zero hardcoded join() calls remain"
    - "Old installs auto-migrate to new structure on first load — no manual intervention"
    - "Every folder has a manifest.json — scripts traverse manifests, never scan directories"
    - "Every .md file has YAML frontmatter — id, type, status, created, links"
    - "Sessions and plans are many-to-many via manifest links — not 1:1"
    - "Archive naming is human-readable: date-mode-trajectory slug"
    - "All 41+ existing tests pass after migration — zero regression"
  artifacts:
    - path: "src/lib/paths.ts"
      provides: "Single source of truth for all .hivemind/ paths"
      contains: "getHivemindPaths"
    - path: "src/lib/migrate.ts"
      provides: "Auto-migration from old to new structure"
      contains: "migrateIfNeeded"
    - path: "src/lib/manifest.ts"
      provides: "Manifest CRUD — read/write/dedup/link at every folder level"
      contains: "readManifest"
---

<objective>
Reorganize .hivemind/ from a flat untraversable mess into a hierarchical,
manifest-driven, YAML-frontmatted, grep-friendly, script-readable structure.

This is THE foundation. Nothing else (context pull, TODO control, hooks) can work
until the data layer is organized correctly.

Target structure:
```
.hivemind/
├── INDEX.md                    # TOC + 3-line state recap (< 30 lines)
├── manifest.json               # Root: version, structure_format, sub-manifests
├── config.json                 # User settings (stays at root — user-facing)
│
├── state/                      # HOT — updated every turn
│   ├── manifest.json           # Lists: brain, hierarchy, anchors, tasks
│   ├── brain.json
│   ├── hierarchy.json
│   ├── anchors.json
│   └── tasks.json              # TODO state (future — placeholder)
│
├── memory/                     # WARM — cross-session intelligence
│   ├── manifest.json           # Shelf counts, last-updated
│   └── mems.json
│
├── sessions/                   # Session lifecycle
│   ├── manifest.json           # Deduped registry, linked plan IDs
│   ├── active/                 # Current session (0-1 files)
│   │   └── {date}-{mode}-{slug}.md  # YAML frontmatter + log
│   └── archive/
│       ├── {date}-{mode}-{slug}.md  # Named archives with frontmatter
│       └── exports/                 # JSON+MD exports
│
├── plans/                      # Plans (INDEPENDENT of sessions)
│   └── manifest.json           # Registry: type, status, linked sessions
│
├── logs/
│   └── self-rate.log
│
├── docs/                       # Design docs (NOT runtime state)
│   └── 10-commandments.md
│
└── templates/
    └── session.md
```
</objective>

<execution_context>
@/Users/apple/.config/opencode/get-shit-done/workflows/execute-plan.md
@/Users/apple/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/STATE.md
@.planning/codebase/CONCERNS.md

@src/lib/planning-fs.ts
@src/lib/persistence.ts
@src/lib/hierarchy-tree.ts
@src/lib/anchors.ts
@src/lib/mems.ts
@src/index.ts
@src/hooks/session-lifecycle.ts
@src/tools/declare-intent.ts
@src/cli.ts
@src/cli/init.ts
</context>

<tasks>

<!-- ============================================================ -->
<!-- STAGE 1: paths.ts — single source of truth                    -->
<!-- Every path in the system flows through this file               -->
<!-- ============================================================ -->

<task type="auto">
  <name>Task 1: Create src/lib/paths.ts — centralized path resolver</name>
  <files>src/lib/paths.ts, tests/paths.test.ts</files>
  <action>
    Create `src/lib/paths.ts` that exports ONE function: `getHivemindPaths(projectRoot)`.

    Returns a typed interface `HivemindPaths` with EVERY path:
    ```typescript
    interface HivemindPaths {
      root: string           // .hivemind/
      config: string         // .hivemind/config.json
      index: string          // .hivemind/INDEX.md
      rootManifest: string   // .hivemind/manifest.json

      // state/ (hot)
      stateDir: string
      stateManifest: string
      brain: string          // state/brain.json
      hierarchy: string      // state/hierarchy.json
      anchors: string        // state/anchors.json
      tasks: string          // state/tasks.json

      // memory/ (warm)
      memoryDir: string
      memoryManifest: string
      mems: string           // memory/mems.json

      // sessions/
      sessionsDir: string
      sessionsManifest: string
      activeDir: string      // sessions/active/
      archiveDir: string     // sessions/archive/
      exportsDir: string     // sessions/archive/exports/

      // plans/
      plansDir: string
      plansManifest: string

      // other
      logsDir: string
      docsDir: string
      templatesDir: string
      sessionTemplate: string
    }
    ```

    Also export:
    - `STRUCTURE_VERSION = "2.0.0"` — bumped when structure changes
    - `getActiveSessionPath(projectRoot)` — resolves via sessions manifest
    - `buildSessionFilename(date, mode, trajectorySlug)` — human-readable
    - `buildArchiveFilename(date, mode, trajectorySlug)` — same format

    Also export legacy compatibility:
    - `getLegacyPaths(projectRoot)` — returns old flat structure paths
    - `isLegacyStructure(projectRoot)` — true if brain.json at root, not in state/

    Write tests:
    - getHivemindPaths returns all expected paths
    - buildSessionFilename produces human-readable names
    - isLegacyStructure detects old vs new
    - All paths are under .hivemind/
  </action>
  <verify>`npx tsx --test tests/paths.test.ts` passes. `npm run typecheck` passes.</verify>
  <done>Single source of truth exists. Every path is typed and centralized.</done>
</task>

<!-- ============================================================ -->
<!-- STAGE 2: manifest.ts — hierarchical manifest system           -->
<!-- JSON manifests at every folder level for script traversal      -->
<!-- ============================================================ -->

<task type="auto">
  <name>Task 2: Create src/lib/manifest.ts — manifest CRUD + dedup</name>
  <files>src/lib/manifest.ts</files>
  <action>
    Create `src/lib/manifest.ts` with typed manifests for each level:

    **RootManifest** (.hivemind/manifest.json):
    ```typescript
    { version: string, structure_format: "2.0.0",
      created: number, sub_manifests: string[] }
    ```

    **StateManifest** (state/manifest.json):
    ```typescript
    { files: Array<{ name: string, purpose: string, last_modified: number }> }
    ```

    **SessionManifest** (sessions/manifest.json) — extend existing:
    ```typescript
    { sessions: Array<{
        stamp: string, file: string, status: string,
        created: number, summary?: string,
        mode?: string, trajectory?: string,
        linked_plans: string[]  // NEW: many-to-many
      }>,
      active_stamp: string | null }
    ```

    **PlanManifest** (plans/manifest.json):
    ```typescript
    { plans: Array<{
        id: string, type: string, status: string,
        created: number, slug: string,
        linked_sessions: string[]  // many-to-many
      }> }
    ```

    **MemoryManifest** (memory/manifest.json):
    ```typescript
    { shelves: Record<string, { count: number, last_updated: number }> }
    ```

    Export CRUD functions:
    - `readManifest<T>(path)` / `writeManifest<T>(path, data)`
    - `deduplicateSessionManifest(manifest)` — removes duplicate stamps
    - `linkSessionToPlan(sessionsManifest, plansManifest, sessionStamp, planId)`
    - `updateMemoryManifest(manifest, memsState)` — syncs shelf counts

    Migrate `registerSession` dedup logic from planning-fs.ts into here.
  </action>
  <verify>`npm run typecheck` passes. Manifest types are consistent.</verify>
  <done>Hierarchical manifest system exists. Every folder level has typed CRUD.</done>
</task>

<!-- ============================================================ -->
<!-- STAGE 3: Wire paths.ts into all existing resolvers            -->
<!-- Replace 4 centralized + 9 scattered path constructions         -->
<!-- ============================================================ -->

<task type="auto">
  <name>Task 3: Migrate all path references to paths.ts</name>
  <files>
    src/lib/planning-fs.ts, src/lib/persistence.ts,
    src/lib/hierarchy-tree.ts, src/lib/anchors.ts, src/lib/mems.ts,
    src/index.ts, src/hooks/session-lifecycle.ts,
    src/tools/declare-intent.ts, src/cli.ts, src/cli/init.ts
  </files>
  <action>
    Replace ALL path construction with imports from paths.ts:

    **Centralized resolvers (delegate, don't duplicate):**
    1. `planning-fs.ts:48 getPlanningPaths()` → delegate to
       `getHivemindPaths()`, map fields for backward compat
    2. `hierarchy-tree.ts:721 getHierarchyPath()` → `getHivemindPaths(p).hierarchy`
    3. `anchors.ts:22 getAnchorsPath()` → `getHivemindPaths(p).anchors`
    4. `mems.ts:33 getMemsPath()` → `getHivemindPaths(p).mems`

    **Scattered hardcoded (replace with import):**
    5. `persistence.ts:21` — brain.json → `paths.brain`
    6. `persistence.ts:109,128` — config.json → `paths.config`
    7. `index.ts:82,84` — config.json, logs → `paths.config`, `paths.logsDir`
    8. `session-lifecycle.ts:414` — config.json → `paths.config`
    9. `declare-intent.ts:71` — config.json → `paths.config`
    10. `cli.ts:103,274` — .hivemind/, config.json → `paths.root`, `paths.config`
    11. `cli/init.ts:215-326` — all directory creation → use paths.ts

    **Validation:** After this task, `grep -r '\.hivemind' src/` should return
    ZERO matches except inside paths.ts itself and string literals in log messages
    or user-facing output text.
  </action>
  <verify>
    `grep -rn 'join.*\.hivemind' src/ | grep -v paths.ts | grep -v '\.md\|log\|comment'`
    returns zero results. `npm run typecheck` passes. `npm test` passes.
  </verify>
  <done>Zero hardcoded .hivemind paths remain outside paths.ts.</done>
</task>

<!-- ============================================================ -->
<!-- STAGE 4: migrate.ts — old → new structure auto-migration      -->
<!-- Detects legacy flat structure, moves files, creates manifests  -->
<!-- ============================================================ -->

<task type="auto">
  <name>Task 4: Create src/lib/migrate.ts — auto-migration</name>
  <files>src/lib/migrate.ts, tests/migration.test.ts</files>
  <action>
    Create `src/lib/migrate.ts`:

    `migrateIfNeeded(projectRoot: string, logger?: Logger): Promise<MigrationResult>`

    Detection: `isLegacyStructure(projectRoot)` from paths.ts — checks if
    brain.json is at `.hivemind/brain.json` (old) vs `.hivemind/state/brain.json` (new).

    Migration steps (all-or-nothing with rollback):
    1. Create new directories: state/, memory/, plans/, docs/, sessions/active/
    2. Move files:
       - brain.json → state/brain.json
       - brain.json.bak → state/brain.json.bak
       - hierarchy.json → state/hierarchy.json
       - anchors.json → state/anchors.json
       - mems.json → memory/mems.json
       - 10-commandments.md → docs/10-commandments.md
    3. Rename session files to human-readable (read YAML frontmatter or
       brain.json for mode/trajectory, construct date-mode-slug.md)
    4. Deduplicate sessions/manifest.json (fix the 5-duplicate-stamp bug)
    5. Create manifests at every folder level
    6. Create INDEX.md with TOC
    7. Add YAML frontmatter to existing .md files that lack it
    8. Write root manifest.json with structure_format: "2.0.0"

    Rollback: if any step fails after file moves, reverse the moves.

    Write tests:
    - Legacy structure detected → migration runs → new structure exists
    - New structure detected → migration skipped
    - Corrupt manifest → deduplication fixes it
    - All moved files are readable at new locations
    - Rollback on failure: original files restored
  </action>
  <verify>`npx tsx --test tests/migration.test.ts` passes. Manual: run on live .hivemind/.</verify>
  <done>Auto-migration works. Old installs upgrade transparently.</done>
</task>

<!-- ============================================================ -->
<!-- STAGE 5: Wire migration into init + plugin boot               -->
<!-- Migration runs automatically — no manual step needed          -->
<!-- ============================================================ -->

<task type="auto">
  <name>Task 5: Wire migration into init and plugin boot</name>
  <files>src/cli/init.ts, src/index.ts, src/hooks/session-lifecycle.ts</files>
  <action>
    **cli/init.ts:** Update directory creation to use new structure from paths.ts.
    On `hivemind init`:
    - Create state/, memory/, sessions/active/, plans/, docs/, logs/, templates/
    - Create all folder-level manifests
    - Create INDEX.md with template TOC
    - Copy 10-commandments.md to docs/ (not root)
    - Create session file with YAML frontmatter

    **index.ts (plugin boot):** After config load, call `migrateIfNeeded(dir, log)`.
    This is the auto-upgrade path — existing users get migrated on first load.

    **session-lifecycle.ts:** After loading config and before first-run detection,
    check `isLegacyStructure()`. If legacy AND migration hasn't run, call
    `migrateIfNeeded()`. This handles the case where plugin boot doesn't trigger
    (e.g., the hook fires before plugin init completes).

    Guard: migration only runs ONCE per session (set a flag in brain state).
  </action>
  <verify>
    `npm test` — all tests pass. `npm run typecheck` passes.
    Manual: delete .hivemind/, run `npx hivemind init`, verify new structure.
    Manual: restore old .hivemind/, start OpenCode session, verify auto-migration.
  </verify>
  <done>Migration is automatic. Init creates new structure. Zero manual steps.</done>
</task>

<!-- ============================================================ -->
<!-- STAGE 6: YAML frontmatter on all session .md files            -->
<!-- Machine-readable metadata + natural language recap             -->
<!-- ============================================================ -->

<task type="auto">
  <name>Task 6: Add YAML frontmatter to session files</name>
  <files>src/lib/planning-fs.ts, src/lib/manifest.ts, src/tools/declare-intent.ts,
         src/tools/compact-session.ts, src/tools/map-context.ts</files>
  <action>
    Every session .md file gets frontmatter:
    ```yaml
    ---
    id: session-1770933850786-bl1u2w
    stamp: "490513022026"
    type: session
    mode: plan_driven
    governance: assisted
    trajectory: "Phase 03: .hivemind reorg"
    tactic: "Execute path migration"
    status: active
    created: 2026-02-13T05:49:00Z
    last_activity: 2026-02-13T06:10:00Z
    turns: 8
    drift: 74
    linked_plans: []
    ---
    # Brief recap (2-3 lines)
    Working on .hivemind reorganization. Paths centralized in paths.ts.
    Migration script created. Stage 3 of 8 complete.
    ```

    Update:
    - `declare-intent.ts` — write frontmatter when creating session file
    - `map-context.ts` — update frontmatter fields (trajectory, tactic, last_activity)
    - `compact-session.ts` — update status to "archived", write to archive with
      full frontmatter
    - `planning-fs.ts` — readActiveMd/writeActiveMd preserve frontmatter
    - Archive naming: `{date}-{mode}-{trajectory-slug}.md`

    Helper in planning-fs.ts or manifest.ts:
    - `parseSessionFrontmatter(content)` — extract YAML
    - `updateSessionFrontmatter(content, updates)` — merge updates
    - YAML dependency already exists (imported in planning-fs.ts line 21)
  </action>
  <verify>
    `npm test` passes. Frontmatter round-trips correctly.
    Manual: declare_intent → read session file → frontmatter present and correct.
  </verify>
  <done>All session files have machine-readable frontmatter + natural language recap.</done>
</task>

<!-- ============================================================ -->
<!-- STAGE 7: INDEX.md with TOC + state digest                     -->
<!-- The "hop or continue" decision point                          -->
<!-- ============================================================ -->

<task type="auto">
  <name>Task 7: Generate INDEX.md as traversable entry point</name>
  <files>src/lib/planning-fs.ts</files>
  <action>
    Create `generateIndexMd(projectRoot)` that produces:

    ```markdown
    ---
    type: index
    structure_version: "2.0.0"
    generated: 2026-02-13T06:10:00Z
    ---
    # .hivemind — Context Governance State

    ## Current State (read this first)
    - Mode: plan_driven | Governance: assisted | Status: OPEN
    - Trajectory: Phase 03 — .hivemind reorg
    - Tactic: Execute path migration
    - Turns: 8 | Drift: 74/100

    ## Quick Navigation
    - [Active Session](sessions/active/{filename}.md)
    - [State Files](state/) — brain, hierarchy, anchors
    - [Memory](memory/) — 4 mems across 3 shelves
    - [Plans](plans/) — 0 active plans
    - [Archives](sessions/archive/) — 3 archived sessions
    - [Config](config.json)

    ## Anchors (immutable facts)
    - [delegation-models]: glm for scan, gemini for investigation...
    - [three-pillars]: packing automation, .hivemind reorg, TODO control
    - [philosophy-corrections]: never act first turn without context...
    ```

    Rules:
    - Under 30 lines (it's a hop-or-continue point, not a doc)
    - Regenerated on every declare_intent and compact_session
    - Links are relative paths — agents can follow them
    - Anchors are inlined because they're immutable and critical
  </action>
  <verify>
    Manual: after declare_intent, read INDEX.md, verify it's under 30 lines,
    all links resolve, state is accurate.
  </verify>
  <done>INDEX.md is the traversable entry point. Agents can hop-or-continue.</done>
</task>

<!-- ============================================================ -->
<!-- STAGE 8: Update all tests                                     -->
<!-- 58 hardcoded path references across 7 test files              -->
<!-- ============================================================ -->

<task type="auto">
  <name>Task 8: Migrate all test path references</name>
  <files>tests/init-planning.test.ts, tests/entry-chain.test.ts,
         tests/integration.test.ts, tests/hierarchy-tree.test.ts,
         tests/round3-tools.test.ts, tests/round4-mems.test.ts,
         tests/ecosystem-check.test.ts</files>
  <action>
    Update all 58 hardcoded path references in tests to use paths.ts:

    ```typescript
    import { getHivemindPaths } from "../src/lib/paths.js"
    const paths = getHivemindPaths(dir)
    // Before: join(dir, ".hivemind", "brain.json")
    // After:  paths.brain
    ```

    Also update assertions that check file existence at old locations.
    Tests that check init behavior need to verify new structure (state/, memory/, etc.).
    Tests for migration need to set up OLD structure and verify NEW structure after.
  </action>
  <verify>
    `npm test` — all 41+ suites pass.
    `npm run typecheck` passes.
    `npm run lint:boundary` passes (paths.ts is in src/lib — no SDK imports).
  </verify>
  <done>All tests use centralized paths. Zero hardcoded .hivemind references in tests.</done>
</task>

<!-- ============================================================ -->
<!-- STAGE 9: Git cleanup + final commit                           -->
<!-- Clean working tree, atomic commit                             -->
<!-- ============================================================ -->

<task type="auto">
  <name>Task 9: Git cleanup and atomic commit</name>
  <files>package.json, package-lock.json, .gitignore</files>
  <action>
    1. Remove self-reference `"hivemind-context-governance": "^2.6.0"` from
       package.json dependencies.
    2. Regenerate package-lock.json.
    3. Add to .gitignore: noise files (session exports, temp docs).
    4. Run migration on live .hivemind/ to prove it works.
    5. Stage everything. Atomic commit:
       "feat(reorg): centralize paths, hierarchical manifests, YAML frontmatter,
       auto-migration from legacy structure"
  </action>
  <verify>
    `npm run build && npm run typecheck && npm test && npm run lint:boundary`
    All pass. `git status` clean. Live .hivemind/ is in new structure.
  </verify>
  <done>Clean git state. New structure live. Ready for user edge-case testing.</done>
</task>

</tasks>

<verification>
1. `npm run build` — clean compile
2. `npm run typecheck` — tsc --noEmit passes
3. `npm test` — all suites pass (existing + new)
4. `npm run lint:boundary` — no SDK imports in src/lib/
5. `grep -rn 'join.*\.hivemind' src/ | grep -v paths.ts` — zero results
6. `git status` — clean working tree
7. Live .hivemind/ in new structure with manifests at every level
8. Old structure auto-migrates on plugin boot
</verification>

<success_criteria>
- ZERO hardcoded .hivemind paths outside src/lib/paths.ts
- Manifests at every folder level — scripts traverse hierarchically
- YAML frontmatter on every .md file
- Sessions and plans are many-to-many via manifest links
- Auto-migration from old structure — zero manual intervention
- INDEX.md under 30 lines — hop-or-continue entry point
- All existing tests pass — zero regression
- Human-readable archive naming
</success_criteria>

<output>
After completion, create `.planning/phases/03-hivemind-reorg/03-01-SUMMARY.md`
</output>

<!-- ============================================================ -->
<!-- MASTER PLAN FRAME                                             -->
<!-- What comes after this phase — user will test with real-life   -->
<!-- edge cases and steer each next item                           -->
<!-- ============================================================ -->

<master_plan_frame>
Phase 03 (THIS): .hivemind/ reorganization — structure, manifests, paths, migration
  → User tests with real-life use cases, addresses edge cases

Phase 04: First-turn context pull + conditional refresh
  - Now possible BECAUSE .hivemind/ is organized and traversable
  - compileFirstTurnContext() reads from state/, memory/, sessions/manifest
  - Conditional refresh: stale detection via manifest timestamps
  - Purification coordination with compaction hook

Phase 05: TODO/Task governance + cross-session continuity
  - state/tasks.json — main + sub tasks, node control
  - TodoWrite upgrade: main/sub split, delegation enforcement
  - Cross-session: export/reload via JSON, link to plans manifest
  - Forced re-read chain on task tick
  - Trajectory as root node connecting TODO, docs, sessions

Phase 06: Packing automation — forced injection via hooks + commands
  - Config-driven injection rules (what fires when)
  - Commands + Skills + Agents for automated context governance
  - Hooks force re-reads at checkpoints — agents can't ignore

Each phase: user leads with edge cases, agent proposes fixes.
</master_plan_frame>
